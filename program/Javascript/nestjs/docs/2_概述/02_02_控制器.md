# 02_02_控制器
- [ ] 控制器`负责`处理传入的`请求`和向客户端返回`响应`。
- [ ] 控制器的`目的`是`接收应用的特定请求`。`路由`机制控制哪个控制器接收哪些请求。通常，每个控制器有多个路由，不同的路由可以执行不同的操作。
- [ ] 为了创建一个基本的控制器，我们使用`类`和`装饰器`。装饰器将类与所需的元数据相关联，并使 Nest 能够创建路由映射（将请求绑定到相应的控制器）。
## 1、路由
- [ ] 在下面的例子中，我们`使用 @Controller() 装饰器定义一个基本的控制器`。可选 `路由路径前缀设置为 cats`。`在 @Controller() 装饰器中使用路径前缀可以使我们轻松地对一组相关的路由进行分组，并最大程度地减少重复代码`。例如，我们可以选择将一组用于管理与 /customers 下的客户实体进行互动的路由进行分组。这样，我们可以在 @Controller() 装饰器中指定路径前缀 customers，这样就不必为文件中的每个路由重复路径的那部分。
- [ ] 要使用 CLI 创建控制器，只需执行 `$ nest g controller cats` 命令。

```typescript
// cats.controller.ts
import { Controller, Get } from '@nestjs/common'

@Controller('cats')
export class CatsController {
    @Get()
    findAll(): string {
        return 'This action returns all cats'
    }
}
```
- [ ] `findAll()` 方法之前的 `@Get()` HTTP 请求方法装饰器告诉 Nest 为 HTTP 请求的特定端点创建处理程序。端点对应于 `HTTP` 请求方法（在本例中为 GET ）和路由路径（如 `GET /customer` ）。什么是`路由路径` ？ `一个处理程序的路由路径是通过连接为控制器 （Controller） 声明的（可选）前缀和请求装饰器中指定的任何路径来确定的`。由于我们已经为每个 route（cats） 声明了一个前缀，并且没有在装饰器中添加任何路由信息，因此 Nest 会将 GET /cats 请求映射到此处理程序。如上所述，该路径包括可选的控制由路径前缀和请求方法装饰器中声明的任何路径字符串。例如，路径前缀 customers 与装饰器 @Get('profile') 组合会为 GET /customers/profile 请求生成路由映射。
- [ ] 在上面的示例中，当对此端点发出 GET 请求时， Nest 会将请求路由到我们的自定义的 findAll() 方法。`请注意，我们在此处选择的函数名称完全是任意的`。显然，我们必须声明一个绑定到路由的函数，但 Nest 不会对所选的函数名称附加任何意义。（译者注：`即路由与处理函数命名无关`）
- [ ] 此函数将返回 200 状态代码和相关的响应，在本例中只返回了一个字符串。为什么会这样？ 为了解释原因，首先我们将介绍 Nest 使用两种不同的操作响应选项的概念：
- 1、标准（推荐）	
- 使用这个内置方法，当请求处理程序返回一个 JavaScript 对象或数组时，它将自动序列化为 JSON。但是，当它返回一个 JavaScript 基本类型（例如string、number、boolean）时， Nest 将只发送值，而不尝试序列化它。这使响应处理变得简单：只需要返回值，其余的由 Nest 负责。
- 2、类库特有的	
- 我们可以`在函数签名处通过 @Res() 注入类库特定的响应对象`（例如， Express）。使用此方法，你就能使用由该响应对象暴露的原生响应处理函数。`例如，使用 Express，您可以使用 response.status(200).send() 构建响应`
- [ ] 注意！Nest 检测处理程序何时使用 `@Res()` 或 `@Next()`，表明你选择了特定于库的选项。如果在一个处理函数上同时使用了这两个方法，那么此处的标准方式就是自动禁用此路由, 你将不会得到你想要的结果。如果需要在某个处理函数上同时使用这两种方法（例如，通过注入响应对象，单独设置 cookie / header，但把其余部分留给框架），你必须在装饰器 `@Res({ passthrough: true })` 中将 passthrough 选项设为 true
## 2、Request
- [ ] 处理程序有时需要访问客户端的请求细节。Nest 提供了对底层平台（默认为 Express）的请求对象（request）的访问方式。我们可以在处理函数的签名中使用 `@Req() 装饰器`，指示 Nest 将请求对象注入处理程序。
```typescript
import { Controller, Get, Req } from '@nestjs/common';
import { Request } from 'express';

@Controller('cats')
export class CatsController {
    // 为了在 express 中使用 Typescript 
    // （如 request: Request 上面的参数示例所示），
    // 请安装 @types/express 。
  @Get()
  findAll(@Req() request: Request): string {
    return 'This action returns all cats';
  }
}

```
- [ ] `Request` 对象代表 `HTTP` 请求，并具有查询字符串，请求参数参数，HTTP 标头（HTTP header） 和 正文（HTTP body）的属性（在[这里](https://expressjs.com/en/api.html#req)阅读更多）。在多数情况下，不必手动获取它们。 我们可以使用专用的装饰器，比如开箱即用的 @Body() 或 @Query() 。 下面是 Nest 提供的`装饰器及其代表的底层平台特定对象的对照列表`。
- [ ] 1、req
> @Request()，@Req()	
- [ ] 2、res
> @Response()，@Res()*	
- [ ] 3、next
> @Next()	
- [ ] 4、req.session
> @Session()
- [ ] 5、req.params / req.params[key]
> @Param(key?: string)	
- [ ] 6、req.body / req.body[key]
> @Body(key?: string)
- [ ] 7、req.query / req.query[key]
> @Query(key?: string)	
- [ ] 8、req.headers / req.headers[name] 
> @Headers(name?: string)	
- [ ] 9、req.ip
> @Ip()	
- [ ] 10、req.hosts
> @HostParam()

- [ ] 为了与底层 HTTP 平台（例如，Express 和 Fastify）之间的类型兼容， Nest 提供了 @Res()和 @Response() 装饰器。@Res() 只是 @Response() 的别名。两者都直接暴露了底层平台的 response 对象接口。在使用它们时，您还应该导入底层库的类型声明（如：@types/express）以充分利用它们。`需要注意的是，在请求处理函数中注入 @Res()或 @Response() 时，会将 Nest 置于该处理函数的特定于库（Library-specific mode）的模式下，并负责管理响应`。这样做时，必须通过调用 `response` 对象（例如，`res.json(…)` 或 `res.send(…)`）发出某种响应，否则 HTTP 服务器将挂起。
> 想要了解如何创建自定义的装饰器，阅读[这一章](https://docs.nestjs.cn/8/customdecorators)。
## 3、资源
- [ ] 我们已经创建了一个端点来获取 cats 的数据（GET 路由）。我们通常还希望提供一个创建新记录的端点。为此，让我们创建 POST 处理程序:
```typescript
// cats.controller.ts
import { Controller, Get, Post, HttpCode, Header } from '@nestjs/common';

@Controller('cats')
export class CatsController {
    @Post()
    // 通过在处理函数外添加 @HttpCode（...） 装饰器来轻松更改此行为
    @HttpCode(204)
    @Header('Cache-Control', 'none')
    create(): string {
        return 'This action adds a new cat';
    }

    @Get()
    // 路由同样支持模式匹配。例如，星号被用作通配符，将匹配任何字符组合。
    // 路由路径 'ab*cd' 将匹配 abcd 、ab_cd 、abecd 等。
    @Get('ab*cd') 
    findAll(): string {
        return 'This action returns all cats';
    }
}

```
- [ ] 就这么简单。 Nest 为所有标准的 HTTP 方法提供了相应的装饰器：`@Put()`、`@Delete()`、`@Patch()`、`@Options()`、以及 `@Head()`。此外，`@All()` 则用于定义一个用于处理所有 HTTP 请求方法的处理程序。
## 4、路由通配符
> @Get('ab*cd')
- [ ] 字符 ? 、+ 、 * 以及 () 是它们的正则表达式对应项的子集。
- [ ] 连字符（-） 和点（.）按字符串路径逐字解析。
## 5、状态码
- [ ] 如上所述，默认情况下，响应的状态码总是默认为 200，除了 POST 请求（默认响应状态码为 201），我们可以通过在处理函数外添加 `@HttpCode（...）` 装饰器来轻松更改此行为。
> @HttpCode(204)
- [ ] 通常，状态码不是固定的，而是取决于各种因素。在这种情况下，您可以`使用类库特有（library-specific）的 response` （通过 @Res()注入 ）对象（或者在出现错误时，抛出异常）。
## 6、Headers
- [ ] 要指定自定义响应头，可以使用 `@Header()` 装饰器或类库特有的响应对象，（并直接调用 `res.header()`）。
## 7、重定向
- [ ] 要将响应重定向到特定的 `URL`，可以使用 `@Redirect()` 装饰器或特定于库的响应对象（并直接调用 `res.redirect()`）。
- [ ] @Redirect() 装饰器有两个可选参数，url 和 statusCode。 如果省略，则 statusCode 默认为 302。



