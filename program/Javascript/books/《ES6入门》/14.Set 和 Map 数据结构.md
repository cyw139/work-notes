# 14_Set 和 Map 数据结构
## 1. Set
### 1.1 基本用法
- ES6 提供了新的数据结构 Set。
- [ ] 它类似于数组，但是`成员值都是唯一的`，没有重复的值。
```javascript
// 案例一 Set的成员值都是唯一的
const s = new Set()
[1,3,5,4,5,2,12].forEach(item => s.add(item))
for(let item of s) {
    console.log(item)
}
// 上面代码通过add()方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。
// 1,3,5,4,2,12

// 案例五 NaN在Set里是相同，在===运算符里是不同的
const set5 = new Set()
const a = NaN
const b = NaN
set5.add(a)
set5.add(b)
console.log(set5) // Set(1) { NaN } 
console.log(a === b) // false

// 案例六 两个对象总是不相等
const set6 = new Set()
set6.add({})
console.log(set6.size) // 1
set6.add({})
console.log(set6.size) // 2
```
- [ ] Set本身是一个`构造函数`，用来生成 Set 数据结构。
- ①Set函数`可以接受一个数组`（或者`具有 iterable 接口`的其他数据结构）作为参数，用来初始化。
- ②向 Set 加入值的时候，`不会发生类型转换`，所以5和"5"是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做`“Same-value-zero equality”`，它`类似于精确相等运算符（===）`，主要的区别是`向 Set 加入值时认为NaN等于自身，而精确相等运算符认为NaN不等于自身`。
- ③两个对象总是不相等。
```javascript
// 案例二 数组去重
const set = new Set([1,2,3,4,4])
// 遍历应用一：扩展运算符（...）内部使用for...of循环，所以也可以用于 Set 结构。
console.log([...set]) // 1,2,3,4
// 等价
// 遍历应用二：扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。
console.log([...new Set([1,2,3,4,4])])
console.log(Array.from(set)) // 1,2,3,4
function dedupe(items) { return Array.from(new Set(items))}
dedupe([1,2,3,4,4])
console.log(set.size) // 4
// 案例三 具有 iterable 接口
const set1 = new Set(document.querySelectorAll('div'))
console.log(set1.size) // 10
// 等价
const set2 = new Set()
document.querySelectorAll('div').forEach(item => set2.add(item))
console.log(set2.size)
// 案例四 字符串去重
console.log([...new Set('abcccdd')].join('')) //abcd
```
### 1.2、Set 实例的属性和方法
```javascript
// Set 实例的属性
Set.prototype.size // 返回Set实例的成员总数。
Set.prototype.constructor // 构造函数，默认就是Set函数。
// Set 实例的方法
Set.prototype.add(value) // 添加某个值，返回 Set 结构本身。
Set.prototype.delete(value) // 删除某个值，返回一个布尔值，表示删除是否成功。
Set.prototype.has(value) // 返回一个布尔值，表示该值是否为Set的成员。
Set.prototype.clear() // 清除所有成员，没有返回值。

// 案例六 Set属性-size/constructor和方法-add/delete/has/clear
const set6 = new Set()
set6.add(1).add(2).add(2)
// 2 true true false true false
console.log(set6.size, set6.has(1), set6.has(2), set6.has(3),set6.delete(2), set6.has(2))

// 案例七 Object和Set判断key存在的方法
const obj = { w: 1, h: 1}
const keyName = 'w'
if (obj[keyName]) {
    
}
const set7 = new Set(['w', 'h'])
if (set7.has(keyName)) {
    
}
```
### 1.3、遍历操作
```javascript
// Set的遍历方法
Set.prototype.keys() // 返回键名的遍历器对象
Set.prototype.values() // 返回键值的遍历器对象
Set.prototype.entries() // 返回键值对的遍历器对象
Set.prototype.forEach() // 使用回调函数遍历每个成员

// 案例八 Set的遍历器-keys/values/entries/forEach
// 注意：Set的遍历顺序就是插入顺序
// 由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），
// 所以keys方法和values方法的行为完全一致。
const set8 = new Set(['red', 'green', 'blue'])
console.log(set8.keys()) // [Set Iterator] { 'red', 'green', 'blue' }
console.log(set8.values()) // [Set Iterator] { 'red', 'green', 'blue' }
// [Set Entries] {
// [ 'red', 'red' ],
//     [ 'green', 'green' ],
//     [ 'blue', 'blue' ]
// }
console.log(set8.entries())
// red
// green
// blue
for (const item of set8.keys()) {
    console.log(item)
}
// red
// green
// blue
for(const item of set8.values()) {
    console.log(item)
}
// [ 'red', 'red' ]
// [ 'green', 'green' ]
// [ 'blue', 'blue' ]
for(const item of set8.entries()) {
    console.log(item)
}

// 案例九 Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。
Set.prototype[Symbol.iterator] === Set.prototype.values // true
// 可以省略values方法，直接用for...of循环遍历 Set。
for(const items of set8) {
    console.log(item)
}

// 案例十 Set 的遍历函数forEach
// red: red Set(3) { 'red', 'green', 'blue' }
// green: green Set(3) { 'red', 'green', 'blue' }
// blue: blue Set(3) { 'red', 'green', 'blue' }
// forEach(callbackfn: (value: T, value2: T, set: Set<T>) => void, thisArg?: any): void;
set8.forEach((value, key, items) => console.log(key + ': ' + value, items), this)

// 案例十一 Set应用三：实现并集（Union）、交集（Intersect）和差集（Difference）
let a = new Set([1, 2, 3])
let b = new Set([4, 3, 2])
// 并集
const set_union = new Set([...a, ...b])
// 交集
const set_intersect = new Set([...a].filter(item => b.has(item)))
// 差集（a 相对于 b 的）
const set_difference = new Set([...a].filter(item => !b.has(item)))

// 案例十二 Set的应用四：
// 在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。
// 一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；
// 另一种是利用Array.from方法。
let set12 = new Set([1,2,3])
set12 = new Set([...set12].map(item => item * 2)) // Set(3) { 2, 4, 6 }
set12 = new Set(Array.from(set12, item => item * 2)) // Set(3) { 4, 8, 12 }

```
## 2、WeakSet
### 2.1、含义
- [ ] WeakSet 结构与 Set 类似，也是`不重复的值的集合`。但是，它与 Set 有两个区别。
- 首先，WeakSet 的成员只能是`对象`和 `Symbol` 值，而不能是其他类型的值。
- 其次，WeakSet 中的`对象都是弱引用`，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。
```javascript
const ws = new WeakSet() 
ws.add(1) // TypeError: Invalid value used in weak set
ws.add(Symbol('test')) // TypeError: Invalid value used in weak set
const a = {'name': 'sam'}
ws.add(a).add(a)
console.log(ws, ws.has(a))
```
- [ ] 这是因为`垃圾回收机制`根据对象的可达性（reachability）来判断回收，如果对象还能被访问到，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。
- [ ] 由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失。另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 `WeakSet 不可遍历`。
### 2.2、语法
## 3、Map
### 3.1、含义和基本用法
- [ ] JavaScript 的`对象（Object）`，本质上是键值对的集合（Hash 结构），但是传统上`只能用字符串当作键`。这给它的使用带来了很大的限制。
```javascript
const data = {}
const element = document.getElementById('myDiv')
data[element] = 'metadata'
// 上面代码原意是将一个 DOM 节点作为对象data的键，但是由于对象只接受字符串作为键名，所以element被自动转为字符串[object HTMLDivElement]。
// data['[object HTMLDivElement]']
console.log(data)
```
- [ ] 为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，`Object 结构提供了“字符串—值”的对应`，`Map 结构提供了“值—值”的对应`，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。
```javascript
// 案例一 Object对象 和 Map对象 的区别
const key = { p: 'hello'}
const value = 'content'
// Object对象
const obj = {}
obj[key] = value
console.log(obj) // { '[object Object]': 'content' }
// Map对象
const map = new Map()
map.set(key, value)
// content true true false
console.log(map.get(key), map.has(key), map.delete(key), map.has(key)) 

// 案例二：Map作为构造函数，接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。
const items = [
    // [key, item]
    ['name', 'Sam'],
    ['title', 'Programer']
]
// 等价
const map2 = new Map()
items.forEach(([key, item]) => map.set(key, item))
```
- [ ] 事实上，不仅仅是数组，①`任何具有 Iterator 接口`、②`且每个成员都是一个双元素的数组的数据结构`（详见《Iterator》一章）`都可以当作Map构造函数的参数`。这就是说，Set和Map都可以用来生成新的 Map。
```javascript
// 案例三： Map构造函数可接受的参数：Array/Set/Map 对象
// [ [ 'id_01', { name: 'sam' } ], [ 'id_02', { name: 'George' } ] ]
const array3 = [['id_01', {'name': 'sam'}], ['id_02', {'name': 'George'}]]
// Set(2) {
//     [ 'id_01', { name: 'sam' } ],
//     [ 'id_02', { name: 'George' } ]
// }
const set3 = new Set(array3)
// Map(2) { 
//      'id_01' => { name: 'sam' }, 
//      'id_02' => { name: 'George' } 
// }
const map3 = new Map(set3)
const map3_1 = new Map(array3)
const map3_2 = new Map(map3_1)
console.info(array3,set3,map3,map3_1, map3_2)

```