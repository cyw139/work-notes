# 03_11_Validation
## 1. 简介
- [x] Laravel 提供了几种不同的方法来验证传入应用程序的数据。最常见的做法是在所有传入的 HTTP 请求中使用 validate 方法。但是，我们还将讨论其他验证方法。
- [x] Laravel 包含了各种方便的验证规则，你可以将它们应用于数据，甚至可以验证给定数据库表中的值是否唯一。我们将详细介绍每个验证规则，以便你熟悉 Laravel 的所有验证功能。

## 2. 快速验证
- [x] 为了了解 Laravel 强大的验证功能，我们来看一个表单验证并将错误消息展示给用户的完整示例。通过阅读概述，这将会对你如何使用 Laravel 验证传入的请求数据有一个很好的理解：
- ### 定义路由
- [x] 首先，假设我们在 routes/web.php 路由文件中定义了下面这些路由：
```php
use App\Http\Controllers\PostController;

Route::get('/post/create', [PostController::class, 'create']);
Route::post('/post', [PostController::class, 'store']);
```
- [x] `GET` 路由会显示一个供用户创建新博客文章的表单，而 POST 路由会将新的博客文章存储到数据库中。
- ### 创建控制器
- [x] 接下来，让我们一起来看看处理这些路由的简单控制器。我们暂时留空了 store 方法：
```php
namespace App\Http\Controllers;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;

class PostController extends Controller
{
    /**
     * 显示创建博客文章的表单。
     *
     * @return \Illuminate\View\View
     */
    public function create()
    {
        return view('post.create');
    }

    /**
     * 存储一篇新的博客文章。
     *
     * @param  \Illuminate\Http\Request  $request
     * @return \Illuminate\Http\Response
     */
    public function store(Request $request)
    {
        // 验证并存储博客文章...
    }
}
```
- ### 编写验证逻辑
- [x] 现在我们开始在 store 方法中编写用来验证新的博客文章的逻辑代码。为此，我们将使用 `Illuminate\Http\Request` 类提供的 `validate`
  方法。如果验证通过，你的代码会继续正常运行。如果验证失败，则会抛出异常，并自动将对应的错误响应返回给用户。
- [x] 在传统 HTTP 请求期间验证失败，则会生成对先前 URL 的重定向响应。如果传入的请求是 XHR，则将返回包含验证错误消息的 JSON 响应。
- [x] 为了深入理解 validate 方法，让我们接着回到 store 方法中：
```php
/**
 * 存储一篇新的博客文章。
 *
 * @param  \Illuminate\Http\Request  $request
 * @return \Illuminate\Http\Response
 */
public function store(Request $request)
{
    // 【验证规则：方式一】使用 | 分隔符
    $validated = $request->validate([
        // 在首次验证失败时停止运行，如果 title 字段没有通过 unique 规则，那么不会继续验证 max 规则。规则会按照分配时的顺序来验证。
        'title' => 'bail|required|unique:posts|max:255',
        'body' => 'required',
        // 嵌套字段的说明。如果你的 HTTP 请求包含「嵌套」参数， 你可以在验证规则中使用「点」语法来指定这些参数：
        'author.name' => 'required',
        'author.description' => 'required',
        // 另外，如果你的字段名称包含点，则可以通过使用反斜杠将点转义，以防止将其解释为 “点” 语法：
        'v1\.0' => 'required',
    ]);
    // 【验证规则：方式二】使用数组
    $validatedData = $request->validate([
        'title' => [
            'bail', 
            'required', 'unique:posts', 'max:255'],
        'body' => ['required'],
    ]);


    // 博客文章验证通过...
}
```
- [x] 如您所见，验证规则被传递到 validate 方法中。不用担心 - 所有可用的验证规则均已记录。另外再提醒一次，如果验证失败，会自动生成一个对应的响应。如果验证通过，那我们的控制器会继续正常运行。
- [x] 或者，验证规则可以使用`数组`而不是单个 `|` 分隔的字符串：
- [ ] 另外，你可以使用 `validateWithBag` 方法来验证请求，并将所有错误信息储存在一个`命名错误信息包`：
```php
$validatedData = $request->validateWithBag('post', [
    'title' => ['required', 'unique:posts', 'max:255'],
    'body' => ['required'],
]);
```
- ### 显示验证的错误信息
- ### 重新填写表单
- ### 可选字段的注意事项
## 3. 表单请求验证
- ###  创建表单请求验证
- ### 表单请求认证授权
- ### 自定义验证错误信息
- ### 准备验证数据
## 4. 手动创建验证器
- ### 自动重定向
- ### 命名错误信息包
- ### 自定义错误信息
- ### 验证后的钩子
## 5. 处理错误信息
- ### 在语言文件中指定自定义消息
- [ ] 【问题-1】Add [pid] to fillable property to allow mass assignment on [App\\Models\\QipaishiSystem\\AreaModel].
```php
# 【问题1-根源】：AreaModel里的 `$fillable` 未设置pid字段造成
# 【文件】：App\\Models\\QipaishiSystem\\AreaModel
protected $fillable = [
    'pid'
]
```
- ### 在语言文件中指定属性
- ### 在语言文件中指定值
## 6. 可用的验证规则
> 下方列出了所有可用的验证规则及其功能：
>> - [x] 1.Accepted
>> - [ ] 2.Active URL
>> - [ ] 3.After (Date)
>> - [ ] 4.After Or Equal (Date)
>> - [x] 5.Alpha
>> - [x] 6.Alpha Dash
>> - [x] 7.Alpha Numeric
>> - [x] 8.[Array](https://learnku.com/docs/laravel/8.5/validation/10378#rule-accepted)
>> - [x] 9.[Bail]()
>> - [ ] 10.Before (Date)
>> - [ ] 11.Before Or Equal (Date)
>> - [ ] 12.Between
>> - [ ] 13.Boolean
>> - [ ] 14.Confirmed
>> - [ ] 15.Date
>> - [ ] 16.Date Equals
>> - [x] 17.Date Format
>> - [ ] 18.Different
>> - [ ] 19.Digits
>> - [ ] 20.Digits Between
>> - [ ] 21.Dimensions (Image Files)
>> - [x] 22.Distinct
>> - [ ] 23.Email
>> - [ ] 24.Ends With
>> - [ ] 25.Exclude If
>> - [ ] 26.Exclude Unless
>> - [x] 27.Exists (Database)
>> - [ ] 28.File
>> - [ ] 29.Filled
>> - [ ] 30.Greater Than
>> - [ ] 31.Greater Than Or Equal
>> - [ ] 32.Image (File)
>> - [x] 33.In
>> - [ ] 34.In Array
>> - [x] 35.Integer
>> - [ ] 36.IP Address
>> - [ ] 37.JSON
>> - [ ] 38.Less Than
>> - [ ] 39.Less Than Or Equal
>> - [x] 40.Max
>> - [ ] 41.MIME Types
>> - [ ] 42.MIME Type By File Extension
>> - [x] 43.Min
>> - [ ] 44.Multiple Of
>> - [ ] 45.Not In
>> - [ ] 46.Not Regex
>> - [x] 47.Nullable
>> - [x] 48.Numeric
>> - [ ] 49.Password
>> - [ ] 50.Present
>> - [ ] 51.Regular Expression
>> - [ ] 52.Required
>> - [ ] 53.Required If
>> - [ ] 54.Required Unless
>> - [ ] 55.Required With
>> - [ ] 56.Required With All
>> - [ ] 57.Required Without
>> - [ ] 58.Required Without All
>> - [ ] 59.Same
>> - [x] 60.Size
>> - [ ] 61.Sometimes
>> - [ ] 62.Starts With
>> - [x] 63.String
>> - [ ] 64.Timezone
>> - [x] 65.Unique (Database)
>> - [ ] 66.URL
>> - [ ] 67.UUID
- [ ] [Accepted](https://learnku.com/docs/laravel/8.5/validation/10378#rule-accepted)
```php
# 1. Accepted
# 【说明】待验证字段必须是 "yes" ，"on" ，1 或 true。这对于验证「服务条款」的接受或类似字段时很有用。
```
```php
# 2. Active URL
# 3. After (Date)
# 4. After Or Equal (Date)
```
```php
# 5. Alpha
# 【说明】待验证字段只能由字母组成。
# 6. Alpha Dash
# 【说明】待验证字段可能包含字母、数字，短破折号（-）和下划线（_）。
# 7. Alpha Numeric
# 【说明】待验证字段只能由字母和数字组成。
$rules = [
    'name' => 'required|alpha'
    'name' => 'required|alpha_dash'
    'name' => 'required|alpha_num'
]
```
- [x] [Array](https://learnku.com/docs/laravel/8.5/validation/10378#rule-array)
```php
# 8. Array
# @todo review 2024-1-26、2024-1-29
# 【说明】待验证字段必须是有效的 PHP 数组
# 【案例一】names = [1, 2, 3]
# <input name="names[]" />
$validator = Validator::make($request->all(), [
    // 检查数据本身，“名称”必须是包含至少3个元素的数组，
    "names"    => "required|array|min:3",
    // 检查数组值，“名称”数组中的值必须是不同的（唯一）字符串，至少3个字符长
    "names.*"  => "required|string|distinct|min:3",
]);
# laravel 5.5，可直接在Request对象上调用validate（）方法
$data = $request->validate([
    "name"    => "required|array|min:3",
    "name.*"  => "required|string|distinct|min:3",
]);

# 【案例二】
$config = [
 { time_long: 4, price: 58.88}, 
 { time_long: 6, price: 68.88 }
 ];
$this->validate($request, [
    'config.*.time_long' => 'required|integer|min:1|max:24',
    'config.*.price' => 'required|numeric',
]);
```
```php
# 9. Bail
# 【说明】在首次验证失败后立即终止验证。
```
```php
# 10. Before (Date)
# 11. Before Or Equal (Date)
# 12. Between
# 13. Boolean
# 14. Confirmed
# 15. Date
# 16. Date Equals
# 17. Date Format
# 18. Different
# 19. Digits
# 20. Digits Between
# 21. Dimensions (Image Files)
# 22. Distinct
# 23. Email
# 24. Ends With
# 25. Exclude If
# 26. Exclude Unless
# 27. Exists (Database)
# 28. File
# 29. Filled
# 30. Greater Than
# 31. Greater Than Or Equal
# 32. Image (File)
# 33. In
```
```php
# 34. In Array
# 【规则】in_array:anotherfield.*
# 【说明】验证的字段必须存在于 anotherfield 的值中。
```
```php
# 35. Integer
# 36. IP Address
# 37. JSON
# 38. Less Than
# 39. Less Than Or Equal
```
```php
# 40. Max
```
```php
# 41. MIME Types
# 42. MIME Type By File Extension
```
- [x] [Min](https://learnku.com/docs/laravel/8.5/validation/10378#rule-nin)
```php
# 43. Min
```
```php
# 44. Multiple Of
# 45. Not In
# 46. Not Regex
```
- [x] [Nullable](https://learnku.com/docs/laravel/8.5/validation/10378#rule-nullable)
```php
# 47. Nullable
#【说明】验证字段可以为 null。
```
- [ ] [Numeric](https://learnku.com/docs/laravel/8.5/validation/10378#rule-numeric)
```php
# 48. Numeric
#【说明】验证字段必须为 数值。
$tests = array(
    "42", // 字符串 -> 整数
    1337, // 整数
    0x539, // 十六进制数
    02471, // 八进制数
    0b10100111001, // 二进制数
    1337e0, // 小数
    
    "0x539", // 字符串
    "02471", // 字符串 -> 整数
    "0b10100111001", // 字符串
    "1337e0", // 字符串 -> 小数
    "not numeric", // 字符串
    array(), // 数组
    9.1, // 小数
    null, // ''
    '',
    
    " 42",
    "42 ",
    "\u{A0}9001", // non-breaking space
    "9001\u{A0}", // non-breaking space
);

foreach ($tests as $element) {
    if (is_numeric($element)) {
        echo var_export($element, true) . " is numeric", PHP_EOL;
    } else {
        echo var_export($element, true) . " is NOT numeric", PHP_EOL;
    }
}

# 【结果】
'42' is numeric
1337 is numeric
1337 is numeric
1337 is numeric
1337 is numeric
1337.0 is numeric
'0x539' is NOT numeric
'02471' is numeric
'0b10100111001' is NOT numeric
'1337e0' is numeric
'not numeric' is NOT numeric
array (
) is NOT numeric
9.1 is numeric
NULL is NOT numeric
'' is NOT numeric

' 42' is numeric
'42 ' is numeric
' 9001' is NOT numeric
'9001 ' is NOT numeric
```
```php
# 49. Password
```
```php
# 50. Present
# 51. Regular Expression
# 52. Required
# 53. Required If
# 54. Required Unless
# 55. Required With
# 56. Required With All
# 57. Required Without
# 58. Required Without All
# 59. Same
```
- [x] [Size:value](https://learnku.com/docs/laravel/8.5/validation/10378#rule-size)
```php
# 60. Size:value
#【说明】验证字段必须与给定的 value 大小一致。
# 1. 对于字符串，value 对应字符数。
# 2. 对于数字，value 对应给定的整数值（该属性必须有 numeric 或者 integer 规则）。
# 3. 对于数组，size 对应数组的 count 值。
# 4. 对于文件，size 对应文件大小（单位 kB）。让我们来看几个例子：

// 验证【字符串长度】是否为 12...
'title' => 'size:12';
// 验证【数字值】是否为 10...
'seats' => 'integer|size:10';
// 验证【数组的长度】（拥有的元素）是否为 5...
'tags' => 'array|size:5';
// 验证【上传的文件大小】是否为 512 kB...
'image' => 'file|size:512';
```
```php
# 61. Sometimes
# 62. Starts With
```
- [x] [String](https://learnku.com/docs/laravel/8.5/validation/10378#rule-string)
```php
# 63. String
# 验证字段必须是一个字符串。如果允许这个字段为 null，需要给这个字段分配 nullable 规则。
#【案例一】
'password' => 'nullable|string|min:4|max:30', # 场景1：更新时
```
```php
# 64. Timezone
```
- [x] [Unique](https://learnku.com/docs/laravel/8.5/validation/10378#rule-unique)
```php
# 65. Unique (Database) 
#【规则】unique:table,column,except,idColumn
#【说明】验证字段在给定的数据库表中必须是唯一的。
# table：①：②指定 Eloquent 模型 / 列名；
# 
$id = $this->get('id')
#【方案一】指定自定义数据表/Eloquent 模型/自定义数据库连接,列名,排除字段值,排除字段
'username'=>'required|max:50|unique:system_user,username,'.$id.',id',
'username'=>'required|max:50|unique:connection.system_user,username,'.$id.',id',
'name'=>'required|string|min:6|max:30|unique:App\Models\AdminModel,name,'.$id.',id',
#【方案二】Rule类处理唯一，忽略某个字段
'username' => [
    'required',
    Rule::unique("system_user")->ignore($id), 
    Rule::unique("system_user", 'email')->ignore($id), # 需要验证的字段email，跟username不一致
]
# 注意：你永远不应该将任何用户控制的请求输入传递给 ignore 方法。你应该只通过 Eloquent 模型的实例来传递系统生成的唯一 ID，例如自动递增 ID 或 UUID 。否则，你的应用程序将更容易受到 SQL 注入攻击。
Rule::unique('users')->ignore($user) # $user 是模型实例，ignore自动获取实例的主键
Rule::unique('users')->ignore($id, 'user_id') # 数据表的主键是user_id，而不是id
Rule::unique('users', 'email_address')->ignore($user->id)
# 增加额外的 Where 语句:
'email' => Rule::unique('users')->where(function ($query) {
    return $query->where('account_id', 1);
    })
```
```php
# 66. URL
# 67. UUID
```

## 7. 按条件添加验证规
## 8. 对数组的验证
## 9. 自定义验证规则
- ### 使用规则类
- ### 使用闭包
- ### 隐式规则